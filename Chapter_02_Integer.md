# 2장 정수

컴퓨터는 0과 1만 인식하므로 사람과 다른 방식으로 수를 표현한다. 양의 정수와 음의 정수가 어떻게 메모리에 저장되는지 알아보자.

# 1. 컴퓨터에서 수를 표현하는 방법

수를 표현하는 방법을 기수법(numeral system)이라 한다.

## 1.1 10진수

10진수는 수를 표현하는데 숫자를 총 10개 사용한다.

## 1.2 2진수

2진수는 수를 표현하는 데 숫자 0과 1만을 사용한다. 컴퓨터가 인식할 수 있는 표현 방법이다.

## 1.3 16진수
16진수는 수를 표현하는데 숫자를 총 열 여섯개 사용한다. 0~9까지의 숫자 10개와 a, b, c, d, e, f 여섯개의 알파벳을 사용한다.

# 2. 10진수를 2진수로
25 -> $1 \times 2^{4} + 1 \times 2^{3} + 0 \times 2^{2} + 0 \times 2^{1} + 1 \times 2^{0}$ -> 11001

```py
>>>bin(25)
'0b11001'
```

bin() 함수는 정수를 2진수로 표현하는 함수이다. 맨 앞에 나오는 0b는 2진수를 의미하는 binary이다.

# 3. 2진수를 10진수로

$1 \times 2^{4} + 1 \times 2^{3} + 0 \times 2^{2} + 0 \times 2^{1} + 1 \times 2^{0}$ -> 25

# 4. 16진수를 2진수로

0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15
0 1 2 3 4 5 6 7 8 9 a b c d e f

마지막 15를 2진수로 변환하면 1111이 된다. 이처럼 16진수 한 자리는 2진수 네 자릿수까지 될 수 있다.

16진수를 2진수로 변환할 때 0부터 9까지 변환하는 방법은 10진수에서 2진수로 변환할 때 쓰는 방법과 같다.

- 16진수 9를 2진수로 변환하기

9 -> 8 + 1 = $2^{3}$ + $2^{0}$

$2^{3} + 2^{0} = 1 \times 2^{3} + 0 \times 2^{2} + 0 \times 2^{1} + 1 \times 2^{0}$

결괏값 = 0b1001

- a는 10진수의 10에 해당한다.

10 -> 8 + 2 = $2^{3} + 2^{1}$
결괏값 = 0b1010


- b는 10진수로 11 -> 0b1011
- c는 10진수로 12 -> 0b1100
- d는 10진수로 13 -> 0b1101
- e는 10진수로 14 -> 0b1110
- f는 10진수로 15 -> 0b1111

# 5. 코딩으로 확인하는 진수 변환

```python
>>> a = 0xa
>>> bin(a)
'0b1010'

>>> b = 0xb
>>> bin(b)
'0b1011'

...

>>>f = 0xf
>>>bin(f)
'0b1111'
```

8비트 컴퓨터의 메모리 주소가 2진수로 0010 1101이라면 2진수 네 자릿수를 16진수 한 자릿수로 표현할 수 있으므로 0x2d로 나타낼 수 있다.
```
>>> address_8bit = 0b00101101
>>> hex(address_8bit)
'0x2d'
```

hex() 함수는 정수를 16진수로 표현한다. 2진수로 표현하면 8비트를 표현하는데 여덟자릿수가 필요하지만 16자릿수로 표현하면 간단히 두 자릿수로 표현이 가능하다.<br>
이러한 이유로 메모리 주소를 나타낼 때는 16진수를 사용한다.

32비트 컴퓨터는 서른두 자릿수의 2진수가 아닌 여덟 자릿수의 16진수를 이용해 표현한다.

```python
>>> address_32비트 = 0x1234abcd
>>> bin(address_32비트)
'0b10010001101001010101111001101'
```

# 6. 양의 정수

정수에는 양수와 음수가 있으므로 부호를 나타내는데 1비트를 사용한다. 맨 앞의 비트가 0이면 양수, 1이면 음수이다.

25를 메모리에 저장할 때 맨 앞의 비트는 양수이므로 0이 된다. 10진수 25를 2진수로 변환하면 11001이므로 나머지 비트를 0으로 채우면 다음과 같이 된다.

00011001
(양수이므로 맨 앞이 0 나머지는 0으로 채운다)

맨 앞의 비트가 부호를 나타낸다는 사실을 제외하고는 10진수를 2진수로 바꾼 것과 같다.

- 1바이트로 나타낼 수 있는 수의 크기는?

$2^{8}$ 즉, 0~255일것 같지만 정수에는 음수가 포함되고 맨 앞의 비트를 부호로 사용하므로 표현할 수 있는 범위는 절반으로 줄어든다. 이에 따라 -128 ~ 127이 된다.

음의 정수를 표현할 때는 방식이 많이 달라진다. 

# 7. 음의 정수

보수에 대해 알아보자. 컴퓨터가 음수를 보수 형태로 저장하므로 음의 정수가 어떻게 저장되는지 이해하려면 보수의 개념이 필요하다.

## 7.1 보수의 개념

보수란 '보충해 주는 수'를 뜻한다.

- 10진수에서 9의 보수
	- 3의 9의 보수는 6
	- 26의 9의 보수는 73
	- 어떤 수의 각 자릿수 수를 9에서 빼면 9의 보수를 구할 수 있다.

- 10의 보수
	- 3의 10의 보수는 3의 9의 보수인 6에 1을 더한 값인 7
	- 26의 10의 보수도 73에 1을 더한 74
	- 123의 9의 보수는 876, 10의 보수는 877
	
## 7.2 2의 보수

- 2진수 1010의 1의 보수는?
	- 1에서 각 자릿수 수를 빼면 된다. 0101이 된다.

- 2진수 1010의 2의 보수는?
	- 위 0101에 1을 더한 0110이 된다.

- 2의 보수가 중유한 이유는 컴퓨터가 음수를 표현할 때 2의 보수를 사용하기 때문이다.


## 7.3 음수의 표현

컴퓨터는 음수를 2의 보수로 표현한다. 음수인 -4가 어떻게 표현되는지 알아보자

- -4의 2의 보수
	-  0000 0100 (4의 2진수)
	-  1111 1011 (1의 보수)
	-  1111 1100 (2의 보수)


```
>>> (-4).to_bytes(1, byteorder='little', signed=True)
b'\xfc'
```

첫번째 인자는 몇 바이트로 나타낼지 지정하는데, 여기서는 1로 지정한다. 두번째 인자는 바이트 오더이고, 마지막 인자는 양수와 음수를 모두 표현할지 아니면 양수만 표현할지 정하는 인수이다.

16진수 0xFC를 2진수로 변환하면 1111 1110 이다. -4의 2의 보수이다.

## 7.4 2의 보수로 표현하는 이유

1. 양수와 음수를 모두 양수처럼 저장한다고 생각하면 0000 0000과 1000 0000은 +0과 -0이 된다. 즉 0을 표현하는 방식이 두가지가 되면서 비트 하나를 낭비하게 되는 것이다. 또한 두 수를 비교할 때 CPU에서 뺄셈을 하는데 +0과 -0을 비교하면 결과 값이 같이 나오지 않을 것이다.

2. 컴퓨터에서 정수의 뺄셈 과정을 살펴보면 뺄셈은 2의 보수 개념을 활용한다. 9 - 4를 계산할 때 9에서 4를 빼는게 아니라 -4를 2의 보수로 만든 다음 더하는 것이다.
