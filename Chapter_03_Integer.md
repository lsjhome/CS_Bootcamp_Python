# 3장 실수

실수 표현은 표현 범위가 넓은 대신 정밀도가 낮다.

# 1. 실수 연산의 함정

```
>>> a = 0.01
>>> result = 0.0
>>> for i in range(100):
		result += a

>>> result
1.0000000000000007

```

1에 가까운 수이지만 1은 아니다.

```
>>> a = 0.015625
>>> a
0.015625
>>> result = 0.0
>>> for i in range(100):
		result += a
>>> result
1.5625
```

이번에는 정확한 결과로 정확한 값이 나왔다. 우연일까?
컴퓨터가 실수를 표현하는 '부동소수점' 이라는 개념을 이해해야 한다.\

# 2. 부동소수점

컴퓨터는 ANSI/IEEE 754-1985 표준에 따라 실수를 표현한다. 이 표현법을 부동소수점이라고 부르는데, 여기서 '부'는 둥둥 떠다닌다는 의미이다.

123.456은 다음과 같이 표현이 가능하다.

1.23456 $\times$ $10^{2}$
12.3456 $\times$ $10^{1}$
1234.56 $\times$ $10^{-1}$
12345.6 $\times$ $10^{-2}$

마치 소수점이 떠다니는 것처럼 보이기 때문에 이러한 실수 표현 방식을 부동소수점이라고 부른다.

# 3. 단정도와 배정도

부동소수점에는 단정도 부동소수점과 배정도 부동소수점이 있다.
- 단정도(single-precision)은 실수를 32비트(4바이트)로 표현하며 부호 1비트, 지수부 8비트, 가수부 23비트로 구성된다.
- 배정도(double-precision)는 실수를 64비트(8바이트)로 표현하며 부호 1비트, 지수부 11비트, 가수부 52비트로 구성된다.
	- 실수를 표현하는데 사용되는 비트 수가 단정도보다 두 배 많은 만큼 정밀도가 높다.
	- 파이썬은 배정도를 사용한다.

```
>>> import sys
>>> sys.float_info
sys.float_info(max=1.7976931348623157e+308, max_exp=1024, max_10_exp=308, min=2.2250738585072014e-308, min_exp=-1021, min_10_exp=-307, dig=15, mant_dig=53, epsilon=2.220446049250313e-16, radix=2, rounds=1)

```


sys 모듈을 임포트한 후 float_info를 입력하면 최댓값, 최솟값, 정밀도 등을 확인할 수 있다.
배정도 부동소수점으로 표현할 수 있는 가장 큰 수를 나타내자.

```
>>> sys.float_info.max
1.7976931348623157e+308
```

e는 지수를 뜻하는 exponent의 줄임말로 다르게 표현하면 다음과 같다.

1.7976931348623157 $\times 10^{308}$

다음은 배정도 부동소수점으로 표현할 수 있는 가장 작은 수를 나타낸다.
```
>>> sys.float_info.min
2.2250738585072014e-308
```

# 4. 1바이트 실수 자료형 설계하기

1바이트 실수 자료형을 직접 만들어 보자.

$\pm$ 1.man $\times$ $2^{exp-bias}$

1.man은 가수(mantissa/fraction), 2는 밑수, $exp-bias$는 지수(exponent)를 의미한다.
7.75라는 10진수 실수를 1바이트 부동소수점으로 표현해 보자.

지금부터 이 식을 이용해 7.75라는 10진수 실수를 1바이트 부동소수점으로 표현해 보자. 이 식은 2진수에 대한 식이므로 우선 7.75라는 10진수 실수를 2진수 실수로 바꾸는 작업이 필요하다.

## 4.1 10진수 실수를 2진수 실수로 바꾸기

10진수 실수를 2진수로 바꾸는 방법은 정수를 바꿨던 방법과 크게 다르지 않다. 여기서 $2^{-1}$은 음수가 아니라 우리가 흔히 분수라고 부르는 1/2이다. $2^{-2}$는 1/4이다. 결국 이를 변환을 하면 111.11이 된다.

7.75 = 4 + 2 + 1 + 0.5 + 0.25 = $2^{2} + 2^{1} + 2^{0} + 2^{-1} + 2^{-2}$ = 111.11

## 4.2 정규화

정규화란 소수점 왼쪽에 위치한 가수 부분을 밑수보다 작은 자연수가 되도록 만드는 것이다. 가령 10진수 567.89를 정규화하면 소수점 왼쪽에 위치한 가수 부분이 밑수 10보다 작은 자연수 5가 되어 5.6789 $\times$ $10^{2}$ 가 된다.

2진수의 밑수는 2이므로 2보다 작은 자연수는 1밖에 없다.  따라서 111.11을 정규화하면 다음과 같다

111.11 = 1.1111 $\times$ $2^{2}$

## 4.3 메모리 구조

정규화된 부동소수점 수 1.1111 $\times$ $2^{2}$을 앞의 수식과 비교해 보면 man은 1111이고 $exp-bias$는 2이다. 이제 1바이트의 메모리 구조를 정하고 man과 exp 값만 저장하면 설계가 끝난다. 이때 지수부와 가수부에 할당하는 비트 수에 따라 표현 범위와 정밀도가 결정된다.

1바이트 부동소수점
- 0 0000 000
부호, 지수부, 가수부

- 실수 역시 정수와 마찬가지로 첫 번째 비트는 부호를 나타낸다. 0이면 양수고 1이면 음수이다.
- 가운데 4비트는 지수부로 exp 값, 맨 뒤 3비트는 가수부로 man 값을 저장한다.
- bias는 지수의 부호를 결정하는데 쓴다. 부동소수점의 지수부에는 부호 비트가 없으며 0~15의 양수만 나타낼 수 있다. 하지만 음수 지수도 필요하다.
	- 음수를 사용하려면 bias를 7로 두고 지수부(exp)에서 bias를 뺀 값을 실제 지수로 사용한다.
	- bias는 $2^{n-1}-1$ 식에 지수부의 비트 수인 4를 대입하면 구할 수 있다.

- 정규화된 수 1.1111 $\times$ $2^{2}$에서 실제 지수는 2이다. 즉, exp - bias가 2라는 것이다. bias가 7이었으니 exp는 9가 된다. 
	- 이제 1바이트를 구성해 보자.
		- 부호 : 0
		- 지수부 : 1001
		- 가수부 : 1111
	- 가수부는 3비트만 할당되는데 우리가 가진 값은 1111이다. 이런 경우에는 뒷자리 1을 생략한다.
		- 0 1001 111 = 0100 1111 = 0x4f
- 실수 7.75는 1바이트 부동소수점으로 나타내면 0x4f이다.

## 4.4 1바이트 부동소수점의 표현 범위
- 표현할 수 있는 가장 작은 수와 가장 큰 수
	- 1.000 $\times$ $2^{-6}$ = 0.015625
	- 1.111 $\times$ $2^{7}$ = 240

## 4.5 1바이트 부동소수점의 정밀도
변환 과정에서 가수부를 담을 공간이 부족해 가수부에 들어갈 데이터인 1111에서 맨 뒤에 있는 1을 누락했다. 이렇게 되면 0x4f는 7.75라는 실수를 완벽하게 표현하지 못한다.
1.111 $\times$ $2^{2}$ = 1 $\times$ $2^{2}$ + 1 $\times$ $2^{1}$ + 1 $\times$ $2^{0}$ + 1 $\times$ $2^{-1}$ = 7.5

0.25마늠 차이가 나므로 정밀도가 그만큼 떨어진다.

# 5. 정밀도에 대한 고찰

## 5.1 엡실론
실수 자료형에서 엡실론이란 1.0과 그 다음으로 표현 가능한 수(represnetable float)사이의 차이를 말한다.
```
>>> import sys
>>> sys.float_info.epsilon
2.220446049250313e-16
```

## 5.2 엡실론과 정밀도

배정도 실수 9.25를 부동소수점 방식으로 나타내면 1.00101 $\times$ $2^{3}$ 이다. 어떤 실수가 있을 때 엡실론을 이용하면 그 실수 다음에 표현할 수 있는 수를 알아낼 수 있다.

```
>>> import sys
>>> ep = sys.float_info.epsilon
>>> a = 9.25
>>> diff = (2**3)*ep # 1
>>> diff
1.7763568394002505e-15

>>> b = a + diff
>>> b
9.250000000000002
```

- \#1 에서 diff는 지수 부분인 $2^{3}$에 엡실론을 곱한 값으로 9.25와 그 다음 표현 가능한 수 사이의 차이이다.
- \#2 에서의 b는 a와 diff의 합이므로 9.25 다음에 표현 가능한 수를 나타낸다.

9.25에 diff보다 작은 값을 더하면 어떻게 될까?

```
>>> a
9.25
>>> half_diff = diff / 2
>>> half_diff
8.881784197001252e-16
>>> c = a + half_diff
>>> a == c
True
```

a는 1.0000 ... ... 00000(0: 52개) $\times$ $2^{53}& a와 a 다음에 표현 가능한 수 사이의 차이는 $2^{53}$에 엡실론을 곱해 구할 수 있으며 그 값은 2.0이다. 그러므로 a에 1.0을 더한 b는 원래 의도한 값을 표현하지 못하고 a와 같은 값을 갖게 된다. 1.0의 차이조차 표현할 수 없는 정밀도이다.

```
>>> a = (2.0) ** 53
>>> a
9007199254740992.0
>>> b = a + 1.0
>>> a == b
True
```


